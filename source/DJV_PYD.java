/* autogenerated by Processing revision 1293 on 2024-02-08 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class DJV_PYD extends PApplet {

/*

 DJV_PYD
 
 */
int menuselect = 0;
int menu = 0;
float px = 0;
float py = 0;
float vx = 0;
float vy = 0;
int t = 0;
int togo = 0;
String[][] menuopts = {
  {
    "load/save test",
    "title screen",
    "cutscene test",
    "sfx test",
    "go to game",
    "easedemo",
    "go to menu"
  },{},{},{
    "back"
  },{},{},{
    "generate data",
    "write generated data",
    "load",
    "do all of the above",
    "back"
  },{},{
    "wandering",
    "hit",
    "angry"
  }
};
Player p;

public byte[] strconv(String s, int score) {
  byte[] sb = {};
  byte[] scoreb = {};
  sb = expand(sb, 16);
  scoreb = expand(scoreb, 4);
  for (int i = 0; i < sb.length; i++) {
    if (s.length()-1<i) {
      sb[i]=0;
      continue;
    }
    byte code = (byte)(s.charAt(i));
    sb[i]=code;
    if (code > 255) sb[i] = 63;
  }
  int scoretemp = score;
  for (int i = 0; i<scoreb.length; i++) {
    scoreb[i] = PApplet.parseByte(scoretemp%256);
    println(binary(scoretemp), scoreb[i], scoretemp%256);
    scoretemp = scoretemp>>8;
  }
  return concat(sb, scoreb);
}

public void setup() {
  //fullScreen(P2D);
  /* size commented out by preprocessor */;
  background(0);
  textSize(48);
  text("LOADING...", 77, 77);
  noStroke();
  frameRate(60);
  surface.setTitle("Polyehdronaid");
  surface.setResizable(false);
  println(P2D);
  p = new Player(500, 500, 0.8f, 4);
  textFont(loadFont("/fonts/MS-Gothic-20.vlw"));
  textSize(20);
  loadwave(waveno);
}
public void draw() {
  t++;
  if(menu != 4)background(0);
  switch (menu) {
  case 0: {
      t--;
      options();
      break;
    }
  case 2: {
    p.move();
    p.display();
    updateparticle();
    enemy();
    rightside(0);
    break;
  }
  case 3: {
    easedemo();
    options();
    break;
  }
  case 4: {
    t = 0;
    menuselect = 0;
    menu = togo;
    if (togo == 4)menu = 0; // dont get stuck in an infinite loop kids its not fun
    break;
  }
  case 5: {
    textSize(20);
    text("wave "+waveno, (width-textWidth("wave " + waveno))/2+500-map2(max(t-120, 0), 0, 30, 500, 0, QUINTIC, EASE_IN), height/2+500-map2(max(50-t, 0), 0, 50, 500, 0, QUINTIC, EASE_IN));
    textSize(32);
    for(int i = 0;i<wavename.length();i++){
      float x = (width-textWidth(wavename))/2+i*16-500+map2(max(t-130+i*2, 0), 0,30, 500, 0, QUINTIC, EASE_IN);
      float y = height/2+36+500-map2(max(30-t+10+i*2, 0), 0, 30, 500, 0, QUINTIC, EASE_IN);
      text(wavename.charAt(i), x, y);
    }
    if(t > 150) {
      rightside(map2(max(t-150, 0), 0, 30, 400, 0, QUINTIC, EASE_OUT));
    }
    if(t==180){
      togo = 2;
      menu = 4;
    }
    break;
  }
  case 6: {
    options();
    ldbrenderdata();
    break;
  }
  case 7: {
    text("go to menu "+menuselect, 100, 100);
    break;
  }
  case 8: {
    options();
    text("enemy movement test", 100, 100);
    emd();
    break;
  }
  default: {
    menu = 0;
  }
  }
}


public void keyPressed() {
  switch (menu) {
  case 0: {
    optchmc();
      switch (keyCode) {
      case 10: {
          switch (menuselect) {
          case 0: {
            ldbload();
            menu = 6;
            break;
            }
          case 4: {
            togo = 5;
            menu = 4;
            break;
            }
          case 5: {
            menu = 3;
            break;
          }
          case 6: {
            menu = 7;
            break;
          }
          }
          break;
        }
      }
      break;
    }
    case 6: {
      optchmc();
      switch (keyCode) {
        case 10: {
          switch (menuselect) {
          case 0: {
            ldbgener = ldbgeneratedata();
            break;
          }
          case 1: {
            saveBytes("leaderboard.dat", ldbgener);
            break;
          }
          case 2: {
            ldbload();
            break;
          }
          case 3: {
            ldbgener = ldbgeneratedata();
            saveBytes("leaderboard.dat", ldbgener);
            ldbload();
            break;
          }
          case 4: {
            menu = 0;
            break;
            }
          }
          break;
        }
      }
    }
    case 2: {
      p.setMove(keyCode, true);
      break;
    }
    case 3: {
      if(keyCode == 10) menu = 0;
      break;
    }
    case 7: {
      switch (keyCode) {
        case 40: {
          menuselect--;
          break;
        }
        case 38: {
          menuselect++;
          break;
        }
        case 10: {
          togo = menuselect;
          menu = 4;
          break;
        }
      }
      break;
    }
    case 8: {
      optchmc();
      break;
    }
  }
}

int[] optpress = {};
public void options() {
  fill(255);
  for (int i = 0; i<menuopts[menu].length; i++) {
    if (i == menuselect) {
      text("> "+ menuopts[menu][i], 20, i*22+20);
    } else {
      text(menuopts[menu][i], 20, i*22+20);
    }
  }
}
public void optchmc() {
  switch (keyCode) {
    case 38: {
      menuselect--;
      if (menuselect<0) menuselect=menuopts[menu].length-1;
      break;
    }
    case 40: {
      menuselect++;
      if (menuselect>menuopts[menu].length-1) menuselect=0;
      break;
    }
  }
}
int textSize = 15;
Button[] buttons = {};
public void mousePressed() {
  for (int i = 0; i < buttons.length; i++) {
    if (buttons[i].checkHover()) {
      buttonClick(buttons[i].ID);
    }
  }
}

public void buttonClick(String id) {
  //do whatever
}
class Button {
  String text;
  String ID;
  float w;
  float h;
  float x;
  float y;
  private boolean wasHovered;
  Button(String t, float _x, float _y, String _id, int _w, int _h) {
    text = t;
    if(w == 0){
      w = textWidth(t);
    } else {
      w = _w;
    }
    if(h == 0){
      h = textSize;
    } else {
      h = _h;
    }
    h = textSize;
    x = _x;
    y = _y;
    ID = _id;
  }
  public void display() {
    if (checkHover())
      fill(150);
    else
      fill(100);
    stroke(255);
    rect(x, y, w + 4, h);
    fill(255);
    text(text, x + 2, y + 2 + textSize);
  }
  public boolean checkHover() {
    boolean hover = mouseX > x && mouseX < y + w && mouseY > y && mouseY < y + h;
    // if (hover && !wasHovered)
      
    wasHovered = hover;
    return hover;
  }
}

/* The map2() function supports the following easing types */
final int LINEAR = 0;
final int QUADRATIC = 1;
final int CUBIC = 2;
final int QUARTIC = 3;
final int QUINTIC = 4;
final int SINUSOIDAL = 5;
final int EXPONENTIAL = 6;
final int CIRCULAR = 7;
final int SQRT = 8;
final String[] EASENAME = {"LINEAR", "QUADRATIC", "CUBIC","QUARTIC", "QUINTIC", "SINUSOIDAL", "EXPONENTIAL", "CIRCULAR", "SQRT"};

/* When the easing is applied (in, out, or both) */
final int EASE_IN = 0;
final int EASE_OUT = 1;
final int EASE_IN_OUT = 2;

/*
 * A map() replacement that allows for specifying easing curves
 * with arbitrary exponents.
 *
 * value :   The value to map
 * start1:   The lower limit of the input range
 * stop1 :   The upper limit of the input range
 * start2:   The lower limit of the output range
 * stop2 :   The upper limit of the output range
 * type  :   The type of easing (see above)
 * when  :   One of EASE_IN, EASE_OUT, or EASE_IN_OUT
 */
public float map2(float value, float start1, float stop1, float start2, float stop2, int type, int when) {
  float b = start2;
  float c = stop2 - start2;
  float t = value - start1;
  float d = stop1 - start1;
  float p = 0.5f;
  switch (type) {
  case LINEAR:
    return c*t/d + b;
  case SQRT:
    if (when == EASE_IN) {
      t /= d;
      return c*pow(t, p) + b;
    } else if (when == EASE_OUT) {
      t /= d;
      return c * (1 - pow(1 - t, p)) + b;
    } else if (when == EASE_IN_OUT) {
      t /= d/2;
      if (t < 1) return c/2*pow(t, p) + b;
      return c/2 * (2 - pow(2 - t, p)) + b;
    }
    break;
  case QUADRATIC:
    if (when == EASE_IN) {
      t /= d;
      return c*t*t + b;
    } else if (when == EASE_OUT) {
      t /= d;
      return -c * t*(t-2) + b;
    } else if (when == EASE_IN_OUT) {
      t /= d/2;
      if (t < 1) return c/2*t*t + b;
      t--;
      return -c/2 * (t*(t-2) - 1) + b;
    }
    break;
  case CUBIC:
    if (when == EASE_IN) {
      t /= d;
      return c*t*t*t + b;
    } else if (when == EASE_OUT) {
      t /= d;
      t--;
      return c*(t*t*t + 1) + b;
    } else if (when == EASE_IN_OUT) {
      t /= d/2;
      if (t < 1) return c/2*t*t*t + b;
      t -= 2;
      return c/2*(t*t*t + 2) + b;
    }
    break;
  case QUARTIC:
    if (when == EASE_IN) {
      t /= d;
      return c*t*t*t*t + b;
    } else if (when == EASE_OUT) {
      t /= d;
      t--;
      return -c * (t*t*t*t - 1) + b;
    } else if (when == EASE_IN_OUT) {
      t /= d/2;
      if (t < 1) return c/2*t*t*t*t + b;
      t -= 2;
      return -c/2 * (t*t*t*t - 2) + b;
    }
    break;
  case QUINTIC:
    if (when == EASE_IN) {
      t /= d;
      return c*t*t*t*t*t + b;
    } else if (when == EASE_OUT) {
      t /= d;
      t--;
      return c*(t*t*t*t*t + 1) + b;
    } else if (when == EASE_IN_OUT) {
      t /= d/2;
      if (t < 1) return c/2*t*t*t*t*t + b;
      t -= 2;
      return c/2*(t*t*t*t*t + 2) + b;
    }
    break;
  case SINUSOIDAL:
    if (when == EASE_IN) {
      return -c * cos(t/d * (PI/2)) + c + b;
    } else if (when == EASE_OUT) {
      return c * sin(t/d * (PI/2)) + b;
    } else if (when == EASE_IN_OUT) {
      return -c/2 * (cos(PI*t/d) - 1) + b;
    }
    break;
  case EXPONENTIAL:
    if (when == EASE_IN) {
      return c * pow( 2, 10 * (t/d - 1) ) + b;
    } else if (when == EASE_OUT) {
      return c * ( -pow( 2, -10 * t/d ) + 1 ) + b;
    } else if (when == EASE_IN_OUT) {
      t /= d/2;
      if (t < 1) return c/2 * pow( 2, 10 * (t - 1) ) + b;
      t--;
      return c/2 * ( -pow( 2, -10 * t) + 2 ) + b;
    }
    break;
  case CIRCULAR:
    if (when == EASE_IN) {
      t /= d;
      return -c * (sqrt(1 - t*t) - 1) + b;
    } else if (when == EASE_OUT) {
      t /= d;
      t--;
      return c * sqrt(1 - t*t) + b;
    } else if (when == EASE_IN_OUT) {
      t /= d/2;
      if (t < 1) return -c/2 * (sqrt(1 - t*t) - 1) + b;
      t -= 2;
      return c/2 * (sqrt(1 - t*t) + 1) + b;
    }
    break;
  };
  return 0;
}

/*
 * A map() replacement that allows for specifying easing curves
 * with arbitrary exponents.
 *
 * value :   The value to map
 * start1:   The lower limit of the input range
 * stop1 :   The upper limit of the input range
 * start2:   The lower limit of the output range
 * stop2 :   The upper limit of the output range
 * v     :   The exponent value (e.g., 0.5, 0.1, 0.3)
 * when  :   One of EASE_IN, EASE_OUT, or EASE_IN_OUT
 */
public float map3(float value, float start1, float stop1, float start2, float stop2, float v, int when) {
  float b = start2;
  float c = stop2 - start2;
  float t = value - start1;
  float d = stop1 - start1;
  float p = v;
  float out = 0;
  if (when == EASE_IN) {
    t /= d;
    out = c*pow(t, p) + b;
  } else if (when == EASE_OUT) {
    t /= d;
    out = c * (1 - pow(1 - t, p)) + b;
  } else if (when == EASE_IN_OUT) {
    t /= d/2;
    if (t < 1) return c/2*pow(t, p) + b;
    out = c/2 * (2 - pow(2 - t, p)) + b;
  }
  return out;
}

public void easedemo(){
  for(int i = 0; i<9; i++){
    fill(255);
    text(EASENAME[i], (i%5)*120+198, 30+PApplet.parseInt(i>4)*400);
    rect((i%5)*120+198, 58+PApplet.parseInt(i>4)*400, 104, 104);
    fill(255, 0, 0);
    text("EASE_IN", 20, 500);
    for(int x = 0; x<100; x++){
      rect(x+(i%5)*120+198,map2(x, 0, 100, 0, 100, i, EASE_IN)+58+PApplet.parseInt(i>4)*400,2, 2+map2(x+1, 0, 100, 0, 100, i, EASE_IN)-map2(x, 0, 100, 0, 100, i, EASE_IN));
    }
    rect((t%100)+(i%5)*120+198,map2((t%100), 0, 100, 0, 100, i, EASE_IN)+58+PApplet.parseInt(i>4)*400,6, 6);
    fill(0, 255, 0);
    text("EASE_OUT", 20, 525);
    for(int x = 0; x<100; x++){
      rect(x+(i%5)*120+198,map2(x, 0, 100, 0, 100, i, EASE_OUT)+58+PApplet.parseInt(i>4)*400,2, 2+map2(x+1, 0, 100, 0, 100, i, EASE_OUT)-map2(x, 0, 100, 0, 100, i, EASE_OUT));
    }
    rect((t%100)+(i%5)*120+195,map2((t%100), 0, 100, 0, 100, i, EASE_OUT)+55+PApplet.parseInt(i>4)*400,6, 6);
    fill(0, 0, 255);
    text("EASE_IN_OUT", 20, 550);
    for(int x = 0; x<100; x++){
      rect(x+(i%5)*120+198,map2(x, 0, 100, 0, 100, i, EASE_IN_OUT)+58+PApplet.parseInt(i>4)*400,2, 2+map2(x+1, 0, 100, 0, 100, i, EASE_IN_OUT)-map2(x, 0, 100, 0, 100, i, EASE_IN_OUT));
    }
    rect((t%100)+(i%5)*120+198,map2((t%100), 0, 100, 0, 100, i, EASE_IN_OUT)+58+PApplet.parseInt(i>4)*400,6, 6);
  }
}
int waveno = 1;
String wavename;
int[][] enemytype = new int[4][8];
float[] enemyxoff = new float[40];
float[] enemyyoff = new float[40];
float[] enemyv = new float[40];
int[] enemyclock = new int[40];
int[] enemystate = new int[40];
int[] enemyhp = new int[40];
float[] enemyRANDID = new float[40]; // h
public void loadwave(int which) {
  t = 0;
  String[] wavetemp = loadStrings("/wave/"+which+".dpw");
  wavename = wavetemp[0];
  for(int y = 1; y<5; y++){
    for(int x = 0; x<8; x++){
      int i = y*8+x-8;
      int th = PApplet.parseInt(wavetemp[y].charAt(x))-48;
      enemytype[y-1][x] = th;
      enemyhp[i] = round(th/2)+3;
      enemyRANDID[i] = PApplet.parseInt(random(0, 128));
      enemyv[i] = random(0, TAU);
    }
  }
}
public void enemy() {
  for(int y = 0; y<4; y++){
    for(int x = 0; x<8; x++){
      int i = y*8+x;
      if(enemyhp[i]<1)continue;
      switch(enemytype[y][x]){
        case 0:
          fill(255, 0, 0);
          break;
        case 1:
          fill(255, 127, 0);
          break;
        case 2:
          fill(255, 255, 0);
          break;
        case 3:
          fill(0, 255, 0);
          break;
        case 4:
          fill(0, 255, 255);
          break;
        case 5:
          fill(0, 127, 255);
          break;
        default:
          fill(77);
      }
      enemyyoff[i]=map2(min(max(t-i*45-100, 0), 90), 0, 90, -600, 0, QUINTIC, EASE_OUT);
      float finalx = x*100+100+enemyxoff[i]+(sin(PApplet.parseFloat(t*(1-enemystate[i])+enemyclock[i]*2*enemystate[i])/30*(enemystate[i]+1)+enemyRANDID[i]*(1-enemystate[i])/100)*sin(enemyv[i])*5)*(enemystate[i]+1);
      float finaly = y*90+40+enemyyoff[i]+(sin(PApplet.parseFloat(t*(1-enemystate[i])+enemyclock[i]*2*enemystate[i])/30*(enemystate[i]+1)+enemyRANDID[i]*(1-enemystate[i])/100)*cos(enemyv[i])*5)*(enemystate[i]+1);
      enemyclock[i]--;
      if(enemyclock[i]<0){
        enemyclock[i] = PApplet.parseInt(random(700, 1500));
        enemyv[i] += random(-0.2f, 0.2f);
        shoot(-1, finalx, finaly, false);// negative particles means its from an enemy and should be treated differently
        enemystate[i]=0;
      }
      rect(finalx, finaly, 70, 70);
      fill(0);
      text(enemyRANDID[i], finalx+30, finaly+30);
      if (-599<enemyyoff[i]) {
        //text("has checked", 400, 30+i*30);
        for(int ip = 0; ip<particlex.length; ip++){
          if(particlet[ip]<0)continue;
          if(rectRect(finalx, finaly, 70, 70, particlex[ip], particley[ip], particlesettings[particlet[ip]][0], particlesettings[particlet[ip]][1])){ // when touch
            enemyhp[i]--;
            particledestroy(ip);
            if(enemyhp[i]<1){
              score+=100+enemytype[y][x]*50;
              if(-80>enemyyoff[i]){
                score+=100;
                addmessage("early kill", 300, 0xFF5AB7B8, 100);
              }
              break;
            }
            enemyclock[i] = 30;
            enemystate[i] = 1;
            enemyv[i] = random(PI, HALF_PI);
          }
        }
      }
    }
  }
}// mm yes } cascade

public void emd() {
  enemyclock[0]--;
  switch (menuselect){ // aka enemystate ingame
    case 0: {
      if(enemyclock[0]<0&&abs(sin(PApplet.parseFloat(t)/30))<0.1f){
        enemyclock[0] = PApplet.parseInt(random(10, 100));
      }
        enemyv[0] = mouseX/( width/TAU);
      text(mouseX/( width/TAU), 300, 600);
      rect(sin(PApplet.parseFloat(t)/30)*sin(enemyv[0])*56+300, sin(PApplet.parseFloat(t)/30)*cos(enemyv[0])*56+300, 70, 70);
      break;
    }
  }
}
byte[] ldbdata;
byte[] ldbgener = {};
int tablerowsize = 20;
public void ldbrenderdata() {
  text("leaderboard.dat", 300, 30);
  for(int i = 0; i<ceil(ldbdata.length/tablerowsize)+1; i++){
    for(int j = 0; j<tablerowsize; j++){
      if(i*tablerowsize+j>ldbdata.length-1)break;
      text(hex(ldbdata[i*tablerowsize+j]), j*28+300, i*20+70);
    }
  }
  text("generated data", 300, 530);
  for(int i = 0; i<ceil(ldbgener.length/tablerowsize)+1; i++){
    for(int j = 0; j<tablerowsize; j++){
      if(i*tablerowsize+j>ldbgener.length-1)break;
      text(hex(ldbgener[i*tablerowsize+j]), j*28+300, i*20+570);
    }
  }
  text("parsed leaderoard.dat data", 300, 280);
  for(int i = 0; i<ceil(ldbdata.length/tablerowsize); i++){
    for(int j = 0; j<tablerowsize-4; j++){
      if(i*tablerowsize+j>ldbdata.length-1)break;
      text(PApplet.parseChar(ldbdata[i*tablerowsize+j]), j*28+300, i*20+320);
    }
    int scoretemp = 0;
    for(int j = 0; j<4; j++){
      scoretemp += ldbdata[i*tablerowsize+j+16]&127; 
      scoretemp <<= 8;
    }
    text(scoretemp, 768, i*20+320);
  }
}
public void ldbload() {
  ldbdata = loadBytes("leaderboard.dat");
}
public String[] ldbparsestring(byte[] ldbdatatemp) {
  String[] togo = {};
  for(int i = 0; i<ldbdatatemp.length/24; i++){
    String togointogo = "";
    for(int j = 0; j<20; j++){
      togointogo = str(PApplet.parseChar(ldbdatatemp[i*24+j]&127));
    }
    togo = append(togo, togointogo);
  }
  return togo;
}
public void ldbsave(String[] namet, int[] scoret){
  byte[] ldbdatatemp = {};
  for (int i = 0; i<namet.length; i++){
    ldbdatatemp = concat(ldbdatatemp, strconv(namet[i], scoret[i]));
  }
  saveBytes("leaderboard.dat", ldbdatatemp);
}
public byte[] ldbgeneratedata() {
  byte[] togo = {};
  for(int i = 0; i<random(3, 7); i++){
    for(int j = 0; j<16; j++){
      togo = append(togo, (byte)(random(65, 122)));
    }
    for(int j = 0; j<4; j++){
      togo = append(togo, (byte)(random(0, 255)));
    }
  }
  return togo;
}
float[] particlex = {}; // x
float[] particley = {}; // y
int[] particlet = {}; // type
int[][] particlesettings = {{10, 20, 15}, {8, 20, 8}}; // x hitbox size, y hitbox size, speed
int[] particlecolor = {color(255, 0, 0), color(255, 255, 0)};
int[][] epartsettings = {{8, 20, 8}};
int[] epartcolor = {color(255, 255, 0)};
int lastshoot = 0;
public void shoot(int type, float x, float y, boolean cooldown) {
  if(cooldown) {
    if(t-lastshoot<15) {
      return;
    } else { 
      lastshoot = t;
    }
  }
  particlex = append(particlex, x);
  particley = append(particley, y);
  particlet = append(particlet, type);
}
public void updateparticle() {
  for (int i = 0; i<particlex.length; i++){
    int type = particlet[i];
    if (type < 0) {
      println(type + " ig was an epart");
      type = abs(type)-1;
      println(type + " ig was an epart");
      fill(epartcolor[type]);
      rect(particlex[i], particley[i], epartsettings[type][0], epartsettings[type][1]);
      particley[i] += epartsettings[type][2];
      if(particley[i]<-100) {
        particlex = removeByIndex(particlex, i);
        particley = removeByIndex(particley, i);
        particlet = removeByIntIndex(particlet, i);
      }
    } else {
      fill(particlecolor[type]);
      rect(particlex[i], particley[i], particlesettings[type][0], particlesettings[type][1]);
      particley[i] -= particlesettings[type][2];
      if(particley[i]<-100) {
        particlex = removeByIndex(particlex, i);
        particley = removeByIndex(particley, i);
        particlet = removeByIntIndex(particlet, i);
      }
    }
  }
}
public void particledestroy(int i){
  particlex = removeByIndex(particlex, i);
  particley = removeByIndex(particley, i);
  particlet = removeByIntIndex(particlet, i);
}
final class Player {
  boolean isLeft, isRight, isUp, isDown, shoot;
  float x, y;
  float vx = 0;
  float vy = 0;
  float a, m;
  
  Player(final int xx, final int yy, final float aa, final float mm) {
    x = xx;
    y = yy;
    a = aa;
    m = mm;
  }
 
  public void display() {
    fill(255);
    rect(x-50/2, y-90/2, 50, 90);
  }
 
  public void move() {
    x += vx;
    y += vy;
    if (x<0) x = 0;
    if (y<0) y = 0;
    if (x>width) x = width;
    if (y>height) y = height;
    vx *= 0.9f;
    vy *= 0.9f;
    if(isDown) vy = max(vy+a, -m);
    if(isUp) vy = min(vy-a, m);
    if(isRight) vx = max(vx+a, -m);
    if(isLeft) vx = min(vx-a, m);
    if(shoot) {
      shoot(1, p.x, p.y, true);
    }
  }
 
  public boolean setMove(final int k, final boolean b) { // thank GOD THIS EXISTS AAAAAA
    switch (k) {
    case +'W':
    case UP:
      return isUp = b;
 
    case +'S':
    case DOWN:
      return isDown = b;
 
    case +'A':
    case LEFT:
      return isLeft = b;
 
    case +'D':
    case RIGHT:
      return isRight = b;
    
    case 32:
      return shoot = b;
 
    default:
      return b;
    }
  }
}
 
public void keyReleased() {
  p.setMove(keyCode, false);
}
public boolean rectRect(float r1x, float r1y, float r1w, float r1h, float r2x, float r2y, float r2w, float r2h) {
  return (r1x + r1w >= r2x)&&( r1x <= r2x + r2w )&&( r1y + r1h >= r2y) &&( r1y <= r2y + r2h);
}
/*
some code i stole off of stack overflow
*/

public float[] removeByIndex(float[] array, int index) {
  int index2 = array.length-1;
  float old = array[index];
  array[index] = array[index2];
  array[index2] = old;
  array = shorten(array);
  return array;
}

public int[] removeByIntIndex(int[] array, int index) { // yeh
  int index2 = array.length-1;
  int old = array[index];
  array[index] = array[index2];
  array[index2] = old;
  array = shorten(array);
  return array;
}

public String[] removeByStringIndex(String[] array, int index) { // YEH
  int index2 = array.length-1;
  String old = array[index];
  array[index] = array[index2];
  array[index2] = old;
  array = shorten(array);
  return array;
}
int score = 0;
public void rightside(float xoff){
  strokeWeight(4);
  stroke(255);
  fill(0, 0, 50);
  rect(width-225+xoff, 3, 256, 42, 6);
  fill(255);
  textSize(32);
  text(nf(score, 10), width-215+xoff, 38);
  textSize(20);
  
  // displaying messages
  strokeWeight(4);
  textSize(20);
  for (int i = 0; i<message.length; i++){
    fill(messagecolor[i]);
    rect(width-214, 56+29*i+max(0, 29+lastmsgdel*2-t*2)+xoff, 203-12-textWidth(str(messagescore[i])), 24, 6);
    rect(width-17-textWidth(str(messagescore[i])), 56+29*i+max(0, 29+lastmsgdel*2-t*2)+xoff, 6+textWidth(str(messagescore[i])), 24, 6);
    fill(255);
    text(message[i], width-210+xoff, 76+29*i+max(0, 29+lastmsgdel*2-t*2));
    text(messagescore[i], width-textWidth(str(messagescore[i]))-15+xoff, 76+29*i+max(0, 29+lastmsgdel*2-t*2));
    messagetime[i]--;
    if(messagetime[i]<0){
      message = removeByStringIndex(message, i);
      messagetime = removeByIntIndex(messagetime, i);
      messagecolor = removeByIntIndex(messagecolor, i);
      messagescore = removeByIntIndex(messagescore, i);
      lastmsgdel = t;
    }
  }
  textSize(20);
  noStroke();
}
String[] message = {};
int[] messagetime = {};
int[] messagecolor = {};
int[] messagescore = {};
int lastmsgdel = 0;
public void addmessage(String msg, int lfspan, int col, int addscore){
  message = append(message, msg);
  messagetime = append(messagetime, lfspan);
  messagecolor = append(messagecolor, col);
  score += addscore;
  messagescore = append(messagescore, addscore);
}


  public void settings() { size(1024, 768); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "DJV_PYD" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
